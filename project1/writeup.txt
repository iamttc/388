1. With reference to the construction of HMAC, explain how changing the design of the API in Part 1.2 to use token = HMAC_[user’s password](user=. . . ) would avoid the length extension vulnerability.

The length extension attack works because we are able to directly append malicious data to the end by recreating the internal state of the hash. We do not need to know the key to accomplish this. HMAC has an additional outer hash which prevents this. If we try to run the length extension attack on an HMAC, we will be appending our data to the end of the internal hash, not directly to the message. If we knew the outer key, this attack would again be possible because we could decrypt the outer hash, then append data to the internal hash as before. Since we don't know either key, this is impossible. HMAC does both data integrity (internal hash) and authentication (external hash).

``` noop noop noop
*Token as HMAC instead of hash
*Hashes we can start with internal state of machine and just append on
*This attack can be done on hashes with construction H(secret ∥ message)[1] when message and the length of secret is known
*"Note that since HMAC doesn't use the construction H(key ∥ message), HMAC hashes are not prone to length extension attacks.[4] The SHA-3 algorithm is not susceptible to this attack.[5]"

https://crypto.stackexchange.com/questions/3349/purpose-of-outer-key-in-hmac/3382#3382
```

2. Briefly explain why the technique you explored in Part 2.2 poses a danger to systems that rely on digital signatures to verify the integrity of programs before they are installed or executed. Examples include Microsoft Authenticode and most Linux package managers. (You may assume that these systems sign MD5 hashes of the programs.)

With the technique explored in Part 2.2, we saw that we can quite easily create programs that have the same MD5 hash but do vastly different things. This is incredibly dangerous to systems that rely on digital signatures to verify the integrity of their programs, since we have now seen that they can be easily tricked into accepting a malicious program that has the same hash as a perfectly fine program. These systems can easily be attacked by someone who at first provides a program that is safe and has a specific MD5 hash, which the package manager will happily verify by hashing the program and letting the user install / execute the program. At another point in time, the attacker can provide a malicious program that when hashed with MD5 will produce the same hash as the safe program. Although the program is actually different, it will pass the package managers integrity verification as it hashes to the same value, and thus a user can be subtly tricked into downloading and executing an unsafe program. If hash collision are easily created, then systems that solely rely on checking digital signatures for integrity verification can be fooled, and thus the systems are vulnerable.

3. Since 2010, NIST has specified that RSA public exponents (e) should be at least 216 + 1. Briefly explain why Bleichenbacher’s attack would not work for these keys.

The Bleichenbacher attack works well for keys with the public exponent e = 3 because the encrypted message is often not affected by the modulus (number produced is less than the modulus), and because it is quite easy to take the cube root of a message. This means we can effectively forge a signature. If NIST wants public exponents to be at least 2^(16) + 1, then this invalidates the Bleichenbacher attack as it relies on the two properties above. With a public exponent of that size, it would produce a huge number that is almost guaranteed to be larger than the public modulus, thus meaning that the modulus affects the resulting signature. This immediately breaks the Bleichenbacher attack because there are now an infinite number of messages that can modulo to the calculated value.

